--!strict

--[[
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘         EVENTBUS MODULE - PRODUCTION GRADE (Signal-Based)      â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ Purpose: Type-safe event communication system                 â•‘
â•‘ Features:                                                      â•‘
â•‘  âœ… Uses Signal library (Production-grade)                    â•‘
â•‘  âœ… Type-safe event handling                                  â•‘
â•‘  âœ… Memory-efficient cleanup                                  â•‘
â•‘  âœ… Enhanced error messages                                   â•‘
â•‘  âœ… Analytics tracking                                        â•‘
â•‘  âœ… Connection management                                     â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“– à¸•à¸±à¸§à¸­à¸¢à¹ˆà¸²à¸‡à¸à¸²à¸£à¹ƒà¸Šà¹‰à¸‡à¸²à¸™:

-- à¸à¸²à¸£à¸ªà¸¡à¸±à¸„à¸£à¸£à¸±à¸šà¸Ÿà¸±à¸‡à¸­à¸µà¹€à¸§à¸™à¸•à¹Œ
local connection = EventBus:On("PlayerJoined", function(playerName, level)
	print(playerName .. " joined with level " .. level)
end)

-- à¸à¸²à¸£à¸ªà¹ˆà¸‡à¸­à¸µà¹€à¸§à¸™à¸•à¹Œ
EventBus:Emit("PlayerJoined", "John", 5)

-- à¸à¸²à¸£à¸ªà¸¡à¸±à¸„à¸£à¸£à¸±à¸šà¸Ÿà¸±à¸‡à¹à¸„à¹ˆà¸„à¸£à¸±à¹‰à¸‡à¹€à¸”à¸µà¸¢à¸§
EventBus:Once("GameStarted", function()
	print("Game has started!")
end)

-- à¸à¸²à¸£à¸–à¸­à¸™à¸à¸²à¸£à¸ªà¸¡à¸±à¸„à¸£
connection:Disconnect()

-- à¸à¸²à¸£à¸–à¸­à¸™à¸à¸²à¸£à¸ªà¸¡à¸±à¸„à¸£à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”à¸‚à¸­à¸‡à¸­à¸µà¹€à¸§à¸™à¸•à¹Œ
EventBus:Off("PlayerJoined")

ğŸ’¡ Best Practices:
- à¸•à¸±à¹‰à¸‡à¸Šà¸·à¹ˆà¸­à¸­à¸µà¹€à¸§à¸™à¸•à¹Œà¹ƒà¸«à¹‰à¸¡à¸µà¸„à¸§à¸²à¸¡à¸«à¸¡à¸²à¸¢à¸Šà¸±à¸”
- à¹ƒà¸Šà¹‰ Once à¸ªà¸³à¸«à¸£à¸±à¸šà¸­à¸µà¹€à¸§à¸™à¸•à¹Œà¸—à¸µà¹ˆà¹€à¸à¸´à¸”à¸„à¸£à¸±à¹‰à¸‡à¹€à¸”à¸µà¸¢à¸§
- à¸—à¸³ cleanup à¸”à¹‰à¸§à¸¢ Disconnect() à¸«à¸£à¸·à¸­ Off()
- à¹ƒà¸Šà¹‰ GetEventNames() à¹€à¸à¸·à¹ˆà¸­ debug
]]

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- DEPENDENCIES
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local Signal = require(game.ReplicatedStorage.Packages.Signal)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- TYPE DEFINITIONS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

type EventCallback = (...any) -> ()
type SignalConnection = typeof(Signal.new():Connect(function() end))

export type EventBus = {
	-- Core methods
	On: (self: EventBus, eventName: string, callback: EventCallback) -> SignalConnection,
	Once: (self: EventBus, eventName: string, callback: EventCallback) -> SignalConnection,
	Emit: (self: EventBus, eventName: string, ...any) -> (),
	Off: (self: EventBus, eventName: string) -> (),
	
	-- Utilities
	Clear: (self: EventBus) -> (),
	GetEventNames: (self: EventBus) -> {string},
	GetListenerCount: (self: EventBus, eventName: string) -> number,
	GetAnalytics: (self: EventBus) -> {[string]: any},
	
	-- Internal
	_signals: {[string]: any},
	_analytics: {[string]: any},
}

local EventBus = {} :: EventBus
EventBus._signals = {}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ANALYTICS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

EventBus._analytics = {
	totalEvents = 0,
	totalEmits = 0,
	eventCounts = {} :: {[string]: {subscribes: number, emits: number}},
	errors = {} :: {{timestamp: number, event: string, error: string}},
	startTime = os.clock(),
}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PRIVATE FUNCTIONS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function getSignal(eventName: string)
	if not EventBus._signals[eventName] then
		EventBus._signals[eventName] = Signal.new()
		EventBus._analytics.totalEvents += 1
		
		-- Track event creation
		if not EventBus._analytics.eventCounts[eventName] then
			EventBus._analytics.eventCounts[eventName] = {
				subscribes = 0,
				emits = 0,
			}
		end
	end
	return EventBus._signals[eventName]
end

local function validateEventName(eventName: any, functionName: string)
	if type(eventName) ~= "string" then
		-- Enhanced error message
		warn("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
		warn(`â•‘          âŒ EventBus:{functionName}() - Invalid Event Name        â•‘`)
		warn("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£")
		warn(string.format("â•‘ Expected: string                                               â•‘"))
		warn(string.format("â•‘ Got:      %-55s â•‘", type(eventName)))
		warn(string.format("â•‘ Value:    %-55s â•‘", tostring(eventName)))
		warn("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£")
		warn("â•‘ ğŸ’¡ Common Issues:                                              â•‘")
		warn("â•‘   â€¢ Event not defined in Events.luau                           â•‘")
		warn("â•‘   â€¢ Typo in event name (e.g., Events.GAEM_START)              â•‘")
		warn("â•‘   â€¢ Using nil or undefined variable                            â•‘")
		warn("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£")
		warn("â•‘ ğŸ“ Stack Trace:                                                â•‘")
		
		local stack = debug.traceback("", 3)
		for line in stack:gmatch("[^\r\n]+") do
			warn("â•‘ " .. line)
		end
		
		warn("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
		
		error(string.format(
			"EventBus:%s() - eventName must be a string, got %s (value: %s)",
			functionName,
			type(eventName),
			tostring(eventName)
		), 3)
	end
end

local function trackError(eventName: string, errorMsg: string)
	table.insert(EventBus._analytics.errors, {
		timestamp = os.clock(),
		event = eventName,
		error = errorMsg,
	})
	
	-- Keep only last 100 errors
	if #EventBus._analytics.errors > 100 then
		table.remove(EventBus._analytics.errors, 1)
	end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PUBLIC METHODS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

--[[
	On: Subscribe to event
	
	@param eventName string - Event name to listen to
	@param callback function - Function to call when event fires
	@return SignalConnection - Connection object (call :Disconnect() to unsubscribe)
	
	Example:
		local conn = EventBus:On("PlayerDied", function(playerName)
			print(playerName .. " died")
		end)
		
		-- Later: conn:Disconnect()
]]
function EventBus:On(eventName: string, callback: EventCallback): SignalConnection
	validateEventName(eventName, "On")
	assert(type(callback) == "function", "callback must be a function")
	
	local signal = getSignal(eventName)
	
	-- Track subscription
	EventBus._analytics.eventCounts[eventName].subscribes += 1
	
	-- Connect with error handling
	local connection
	connection = signal:Connect(function(...)
		local success, err = pcall(callback, ...)
		if not success then
			trackError(eventName, tostring(err))
			warn(string.format(
				"[EventBus] âŒ Error in listener for '%s': %s",
				eventName,
				tostring(err)
			))
		end
	end)
	
	return connection
end

--[[
	Once: Subscribe to event (fires only once)
	
	@param eventName string - Event name
	@param callback function - Function to call
	@return SignalConnection - Connection (auto-disconnects after first fire)
	
	Example:
		EventBus:Once("GameStarted", function()
			print("Game started!")
		end)
]]
function EventBus:Once(eventName: string, callback: EventCallback): SignalConnection
	validateEventName(eventName, "Once")
	assert(type(callback) == "function", "callback must be a function")
	
	local signal = getSignal(eventName)
	
	-- Track subscription
	EventBus._analytics.eventCounts[eventName].subscribes += 1
	
	-- Use Signal's Once method
	local connection
	connection = signal:Once(function(...)
		local success, err = pcall(callback, ...)
		if not success then
			trackError(eventName, tostring(err))
			warn(string.format(
				"[EventBus] âŒ Error in Once listener for '%s': %s",
				eventName,
				tostring(err)
			))
		end
	end)
	
	return connection
end

--[[
	Emit: Fire event with data
	
	@param eventName string - Event name
	@param ... any - Arguments to pass to listeners
	
	Example:
		EventBus:Emit("PlayerJoined", "John", 5, true)
]]
function EventBus:Emit(eventName: string, ...: any)
	validateEventName(eventName, "Emit")
	
	local signal = EventBus._signals[eventName]
	if signal then
		-- Track emit
		EventBus._analytics.totalEmits += 1
		EventBus._analytics.eventCounts[eventName].emits += 1
		
		-- Fire signal (Signal library handles errors internally)
		signal:Fire(...)
	end
	-- If no signal exists, no listeners are registered (silent ignore)
end

--[[
	Off: Disconnect all listeners for event
	
	@param eventName string - Event name
	
	Example:
		EventBus:Off("PlayerJoined")
]]
function EventBus:Off(eventName: string)
	validateEventName(eventName, "Off")
	
	local signal = EventBus._signals[eventName]
	if signal then
		-- Destroy signal (disconnects all connections)
		signal:Destroy()
		EventBus._signals[eventName] = nil
		
		-- Keep analytics data
		EventBus._analytics.totalEvents -= 1
	end
end

--[[
	Clear: Disconnect all events
	
	âš ï¸ Warning: Removes ALL event listeners!
	
	Example:
		EventBus:Clear()
]]
function EventBus:Clear()
	for eventName, signal in pairs(EventBus._signals) do
		if signal then
			signal:Destroy()
		end
		EventBus._signals[eventName] = nil
	end
	
	-- Reset analytics
	EventBus._analytics.totalEvents = 0
end

--[[
	GetEventNames: Get list of all registered events
	
	@return {string} - Array of event names
	
	Example:
		local events = EventBus:GetEventNames()
		for _, name in ipairs(events) do
			print("Event:", name)
		end
]]
function EventBus:GetEventNames(): {string}
	local names = {}
	for eventName, _ in pairs(EventBus._signals) do
		table.insert(names, eventName)
	end
	return names
end

--[[
	GetListenerCount: Get number of listeners for event
	
	@param eventName string - Event name
	@return number - Number of active listeners
	
	Example:
		local count = EventBus:GetListenerCount("PlayerJoined")
		print("Listeners:", count)
]]
function EventBus:GetListenerCount(eventName: string): number
	validateEventName(eventName, "GetListenerCount")
	
	local signal = EventBus._signals[eventName]
	if signal and signal.GetConnectionCount then
		return signal:GetConnectionCount()
	end
	return 0
end

--[[
	GetAnalytics: Get analytics data
	
	@return table - Analytics data
	
	Example:
		local analytics = EventBus:GetAnalytics()
		print("Total events:", analytics.totalEvents)
		print("Total emits:", analytics.totalEmits)
]]
function EventBus:GetAnalytics(): {[string]: any}
	local uptime = os.clock() - EventBus._analytics.startTime
	
	return {
		totalEvents = EventBus._analytics.totalEvents,
		totalEmits = EventBus._analytics.totalEmits,
		eventCounts = EventBus._analytics.eventCounts,
		errors = EventBus._analytics.errors,
		uptime = uptime,
		emitsPerSecond = uptime > 0 and EventBus._analytics.totalEmits / uptime or 0,
	}
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- DEBUG UTILITIES
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

--[[
	PrintSummary: Print summary of all events (debug)
]]
function EventBus:PrintSummary()
	print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
	print("â•‘                    EVENTBUS SUMMARY                            â•‘")
	print("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£")
	
	local analytics = self:GetAnalytics()
	print(string.format("â•‘ Total Events: %d", analytics.totalEvents))
	print(string.format("â•‘ Total Emits: %d", analytics.totalEmits))
	print(string.format("â•‘ Emits/sec: %.2f", analytics.emitsPerSecond))
	print(string.format("â•‘ Uptime: %.2fs", analytics.uptime))
	print("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£")
	
	if analytics.totalEvents > 0 then
		print("â•‘ Events:")
		for eventName, stats in pairs(analytics.eventCounts) do
			local listeners = self:GetListenerCount(eventName)
			print(string.format(
				"â•‘   %-30s Listeners: %d, Emits: %d",
				eventName,
				listeners,
				stats.emits
			))
		end
	end
	
	if #analytics.errors > 0 then
		print("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£")
		print(string.format("â•‘ Recent Errors: %d", #analytics.errors))
		for i = math.max(1, #analytics.errors - 5), #analytics.errors do
			local err = analytics.errors[i]
			print(string.format("â•‘   [%.2fs] %s: %s", err.timestamp, err.event, err.error:sub(1, 40)))
		end
	end
	
	print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
end

return EventBus